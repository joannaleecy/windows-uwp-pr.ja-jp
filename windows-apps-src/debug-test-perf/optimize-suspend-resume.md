---
author: jwmsft
ms.assetid: E1943DCE-833F-48AE-8402-CD48765B24FC
title: 中断/再開の最適化
description: プロセス継続時間システムの使用を合理化することで、中断または終了の後効率的に再開されるユニバーサル Windows プラットフォーム (UWP) アプリを作成します。
ms.author: jimwalk
ms.date: 02/08/2017
ms.topic: article
keywords: Windows 10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: 4cbaa56f9c25c0e4ea1f10c79b4f7d1100748532
ms.sourcegitcommit: ca96031debe1e76d4501621a7680079244ef1c60
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/31/2018
ms.locfileid: "5834622"
---
# <a name="optimize-suspendresume"></a>中断/再開の最適化


プロセス継続時間システムの使用を合理化することで、中断または終了の後効率的に再開されるユニバーサル Windows プラットフォーム (UWP) アプリを作成します。

## <a name="launch"></a>起動

中断/終了の後、アプリを再アクティブ化するときは、長い時間が経過したかどうかを確認します。 長時間経過している場合は、ユーザーの古いデータを表示する代わりに、アプリのメイン ランディング ページに戻ることを検討してください。 これにより、起動時間も短縮されます。

アクティブ化では、常に、イベント引数のパラメーターの PreviousExecutionState を確認します (たとえば、起動済みのアクティブ化では、LaunchActivatedEventArgs.PreviousExecutionState を確認します)。 この値が ClosedByUser または NotRunning の場合は、以前に保存された状態を復元することで時間をむだにしないでください。 この場合、適切な処理は新しいエクスペリエンスを提供することであり、結果として起動時間も短縮されます。

以前に保存した状態を頻繁に復元する代わりに、その状態を追跡して、要求された場合にのみ復元することを検討します。 たとえば、以前にアプリが一時停止され、3 つのページの状態を保存した後、終了された場合を考えてみます。 再起動時に、ユーザーに対して 3 番目のページを表示する場合は、最初の 2 つのページの状態を頻繁に復元しないでください。 代わりに、この状態を保持し、必要であることがわかった場合にのみ使用します。

## <a name="while-running"></a>実行中

ベストプラクティスとして、中断イベントを待機し、大量の状態を保持することはしないでください。 代わりに、アプリケーションの実行中に少しずつ状態を保持するようにします。 これは、中断時にすべてを一度に保存しようとすると時間が不足する可能性がある、大規模なアプリで特に重要です。

ただし、段階的な保存と実行中のアプリのパフォーマンスの最適なバランスを見つける必要があります。 適切な妥協点は、変更された (つまり保存する必要がある) データを段階的に追跡し、中断イベントを使って実際にそのデータを保存することです (すべてのデータを保存したり、アプリ全体の状態を調べて保存する対象を決定したりするよりも高速です)。

ウィンドウの Activated イベントや VisibilityChanged イベントを使って、状態を保存するタイミングを決定しないでください。 ユーザーがアプリを切り替えたときに、ウィンドウは非アクティブ化されますが、システムはアプリを中断するまでしばらくの間 (約 10 秒間) 待機します。 これにより、ユーザーがすぐに元のアプリに切り替えた場合に、応答性の高いエクスペリエンスを提供します。 中断ロジックを実行する前に、中断イベントを待機します。

## <a name="suspend"></a>中断

中断時に、アプリのメモリ使用量を削減します。 中断中のアプリのメモリ使用量が少なくなると、システム全体の応答性が高くなり、(お客様のアプリを含む) 中断されたアプリが終了されることが少なくなります。 ただし、メモリ使用量と迅速な再開の必要性のバランスを考慮する必要があります。メモリ使用量を削減しすぎると、メモリに大量のデータを再び読み込むことが必要になり、再開が大幅に遅くなります。

マネージ アプリの場合、アプリの中断ハンドラーが完了した後、システムはガベージ コレクション パスを実行します。 これを利用して、中断中のアプリのメモリ使用量の削減に役立つオブジェクトへの参照を解放します。

アプリで 1 秒未満で中断ロジックを完了することをお勧めします。 中断は迅速に完了できるほどよく、他のアプリやシステムの部分の迅速なユーザー エクスペリエンスにつながります。 必要な場合は、デスクトップ デバイスで最大 5 秒間、モバイル デバイスでは 10 秒間、中断ロジックの処理に時間をかけることができます。 これらの時間を超過した場合、アプリは突然終了します。 これは望ましい結果ではありません。この場合、ユーザーがアプリに戻るときに、新しいプロセスが開始され、中断中のアプリを再開するときよりも、エクスペリエンスは非常に遅く感じられるためです。

## <a name="resume"></a>再開

ほとんどのアプリでは、再開時に特別な処理を行う必要がないため、通常、このイベントは処理しません。 一部のアプリでは、再開を利用して、中断時に終了された接続を復元したり、古くなっている可能性があるデータを更新したりします。 このような作業を頻繁に行う代わりに、必要に応じてこれらのアクティビティを開始するようアプリを設計します。 これにより、ユーザーが中断中のアプリに戻ったときのエクスペリエンスが迅速になり、ユーザーが実際に必要としている作業のみを行っていることが保証されます。

## <a name="avoid-unnecessary-termination"></a>不必要な終了の回避

UWP のプロセス継続時間システムは、さまざまな理由でアプリを中断または終了することがあります。 このプロセスは、アプリを中断または終了する前の状態にすばやく戻すように設計されています。 うまく機能すると、アプリの実行が停止していたことにユーザーは気付きません。 ここでは、UWP アプリで、システムがアプリの有効期間内で切り替えを効率的に行うのに役立つヒントをいくつか紹介します。

ユーザーがアプリをバックグラウンドに移動した場合、またはシステムが低電力状態に切り替わった場合にアプリを中断できます。 アプリが中断される際、アプリは suspending イベントを発生して、最長で 5 秒間かけてデータを保存します。 アプリの suspending イベント ハンドラーが 5 秒以内に処理を完了できなかった場合、システムはアプリが応答を停止したと判断してアプリを終了します。 終了したアプリは、ユーザーがそのアプリに切り替えたときに、すぐにメモリに読み込まれることはなく、長い起動プロセスをもう一度実行する必要があります。

### <a name="serialize-only-when-necessary"></a>必要最小限のシリアル化

中断時にすべてのデータをシリアル化するアプリは少なくありません。 しかし、アプリの設定データのうち、保存する必要のあるデータがごくわずかであれば、シリアル化ではなく、[**LocalSettings**](https://msdn.microsoft.com/library/windows/apps/BR241622) ストアを使うことをお勧めします。 シリアル化は、もっと大量のデータや、設定以外のデータに使います。

データをシリアル化する際、変更されていないデータを再シリアル化することは避けてください。 データのシリアル化と保存に時間がかかるばかりか、アプリが再びアクティブ化されたときにもデータの読み取りと逆シリアル化に時間がかかります。 このような処理ではなく、アプリの状態が実際に変更されたかどうかをアプリが判定し、変更された場合にのみ変更データをシリアル化および逆シリアル化する処理をお勧めしています。 この処理を確実に行う良い方法は、データが変更された後にバックグラウンドでこまめにシリアル化することです。 この手法を使うと、中断時にシリアル化する必要があるすべてのデータが既に保存されているため、必要な作業がなく、アプリがすぐに中断されます。

### <a name="serializing-data-in-c-and-visual-basic"></a>C# と Visual Basic でのデータのシリアル化

.NET アプリで使うことができるシリアル化技術には、[**System.Xml.Serialization.XmlSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.xml.serialization.xmlserializer.aspx) クラス、[**System.Runtime.Serialization.DataContractSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.datacontractserializer.aspx) クラス、[**System.Runtime.Serialization.Json.DataContractJsonSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.json.datacontractjsonserializer.aspx) クラスがあります。

パフォーマンスの観点から、[**XmlSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.xml.serialization.xmlserializer.aspx) クラスを使うことをお勧めします。 **XmlSerializer** は、シリアル化と逆シリアル化の処理時間が最も短く、メモリ使用量も低く抑えられます。 **XmlSerializer** と .NET Framework の間には依存関係が少ないため、他のシリアル化技術と比較して、**XmlSerializer** を使うためにアプリに読み込む必要があるモジュールが少なくて済みます。

**XmlSerializer** と比べて、[**DataContractSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.datacontractserializer.aspx) は、カスタム クラスを比較的容易にシリアル化できる反面、パフォーマンスへの影響は大きくなります。 より高いパフォーマンスが必要な場合は、切り替えを検討してください。 通常、複数のシリアライザーを読み込むことは避け、できれば **XmlSerializer** を使うようにしてください (他のシリアライザーの機能を必要とする場合を除く)。

### <a name="reduce-memory-footprint"></a>メモリ使用量の削減

システムは、ユーザーがアプリをすばやく簡単に切り替えられるよう、中断されたアプリを可能な限り多く保持しようとします。 中断され、システムのメモリ内に保持されているアプリは、スプラッシュ画面の表示や長時間の読み込み操作なしでユーザーのフォアグラウンドにすぐに戻ることができます。 十分なリソースがなくアプリをメモリに保持できない場合は、アプリが終了されます。 そのため、次の 2 つの理由でメモリ管理が重要になります。

-   中断時にできるだけ多くのメモリを解放すると、中断しているときにアプリがリソース不足によって終了する可能性が最小限に抑えられます。
-   アプリが使うメモリの総量を減らすと、中断している他のアプリが終了する可能性が低くなります。

### <a name="release-resources"></a>リソースの解放

ファイルやデバイスなどの特定のオブジェクトは、大量のメモリを占有します。 中断中は、アプリがこれらのオブジェクトへのハンドルを解放し、必要なときにハンドルを再作成することをお勧めします。 また、これは、アプリが再開したときに使われないキャッシュを削除する良い機会でもあります。 XAML フレームワークでは、必要に応じて、C# と Visual Basic を使ったアプリに対してガベージ コレクションを追加手順として実行します。 これによって、アプリ コードで参照されなくなったすべてのオブジェクトが解放されます。

## <a name="resume-quickly"></a>迅速な再開

中断中のアプリは、ユーザーがフォアグラウンドにアプリを移動した場合、またはシステムが低電力状態から復帰した場合に再開することができます。 アプリを中断状態から再開すると、アプリは中断された時点から再開されます。 アプリが長時間中断されていた場合でも、アプリのデータはメモリに格納されているため失われることはありません。

ほとんどのアプリでは、[**Resuming**](https://msdn.microsoft.com/library/windows/apps/BR205859) イベントを処理する必要はありません。 アプリ再開時の変数とオブジェクトは、アプリが中断された時とまったく同じ状態です。 アプリの中断と再開の間でデータまたはオブジェクトが変更されている可能性があり、それらの更新が必要な場合にのみ **Resuming** イベントを処理してください。この状況としては、コンテンツ (更新フィード データなど) やネットワーク接続が無効になった場合や、デバイス (Web カメラなど) へのアクセスを再取得する必要がある場合が考えられます。

## <a name="related-topics"></a>関連トピック

* [アプリの中断と再開のガイドライン](https://msdn.microsoft.com/library/windows/apps/Hh465088)
 

 




